Alcide kAudit - Static Audit Configuration
++++++++++++++++++++++++++++++++++++++++++

Content
-------
1) Integrating of kAudit via Fluentd
2) Integration of kAudit via Logstash
3) Direct Integration of kAudit
4) Applying k8s Audit Configurations

NOTE: code in this document may become obsolete, the actual source/configuration files are the source of truth!

1) Integrating of kAudit via Fluentd
====================================
1. Install and Configure Fluentd
-------------------------------- 

a. Using Fluentd Helm chart
Use: https://hub.helm.sh/charts/stable/fluentd

b. Using kubectl

cat <<EOF > fluentd_deployment.yaml
---
kind: Service
apiVersion: v1
metadata:
  name: k8s-log-pipeline
spec:
  selector:
    app: k8s-log-pipeline
  ports:
    - protocol: TCP
      port: 8888
      targetPort: 8888
      name: input
---
apiVersion: v1
kind: Secret
metadata:
  name: k8s-log-pipeline-input-tls-secret
  labels:
    app: k8s-log-pipeline
type: Opaque
stringData:
  cert: |-
    incert
  priv-key: |-
    inprivkey
  priv-key-password: |-
    inprivkeypassword
  ca: |-
    inca
  ca-password: |-
    incapassword
---
apiVersion: v1
kind: Secret
metadata:
  name: k8s-log-pipeline-output-tls-secret
  labels:
    app: k8s-log-pipeline
type: Opaque
#stringData:
#  cert: |-
#    outcert
#  priv-key: |-
#    outprivkey
#  priv-key-password: |-
#    outprivkeypassword
#  ca: |-
#    outca
#  ca-password: |-
#    outcapassword
data:
  cert: ""
  priv-key: ""
  priv-key-password: ""
  ca: ""                              # the CA of the output endpoint (kAudit)  (base64 encoded)
  ca-password: ""
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k8s-log-pipeline-config-kaudit
  labels:
    app: k8s-log-pipeline
data:
  kaudit-webhook: https://kaudit.alcide-kaudit.svc:443/auditsink # kaudit webhook to send to
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k8s-log-pipeline-config
  labels:
    app: k8s-log-pipeline
data:
  fluentd: |
    # Connecting to k8s api server using a WebHook:
    <source>
      @type http
      # the port exposed by the fluentd pod
      port 8888

      # possible options:
      #bind 0.0.0.0
      #body_size_limit 32m
      #keepalive_timeout 10s

      #<transport tls>
        # TLS configuration, see: https://docs.fluentd.org/plugin-helper-overview/api-plugin-helper-server#configuration-example
        # cert_path, private_key_path should match the k8s WebHook Configuration (kubeconfig) below:
        #    client-certificate: /path/to/cert.pem
        #    client-key: /path/to/key.pem
        #cert_path /etc/secrets/input/in.crt
        #private_key_path /etc/secrets/input/in_priv_key
        #private_key_passphrase "#{ENV["TLS_IN_PRIVATE_KEY_PASSPHRASE"]}"

        # For Cert signed by public CA
        #ca_path /etc/secrets/input/in_ca.crt
        #cert_path /etc/secrets/input/in.crt
        #private_key_path /etc/secrets/input/in_priv_key
        #private_key_passphrase "#{ENV["TLS_IN_PRIVATE_KEY_PASSPHRASE"]}"
        #client_cert_auth false

        # For Cert generated and signed by private CA Certificate
        #ca_cert_path /etc/secrets/input/ca_cert_file
        #ca_private_key_path /etc/secrets/input/ca_priv_key_file
        #ca_private_key_passphrase "#{ENV["TLS_IN_CA_PRIVATE_KEY_PASSPHRASE"]}"
      #</transport>

      <parse>
      @type none
      </parse>
    </source>

    # match the tag set by the source, so whatever comes to: http://<fluentd-service>/audit:8888
    <match audit>
      @type http
      # kAudit URL, from its service name & port and /auditsink suffix
      endpoint "#{ENV['KAUDIT_WEBHOOK']}"
      # method post or put, post is default
      #https_method post
      content_type application/json
      <format>
      @type single_value
      </format>

      # TLS configuration
      # CA certificate
      tls_ca_cert_path /etc/secrets/output/out_ca.crt
      # client certificate
      #tls_client_cert_path /etc/secrets/output/out.crt
      # private key certificate
      #tls_private_key_path /etc/secrets/output/priv_key
      # private key passphrase
      #tls_private_key_passphrase "#{ENV["TLS_OUT_PRIVATE_KEY_PASSPHRASE"]}"
      # TLS verify mode, peer or none, defult is peer
      #tls_verify_mode
    </match>
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: k8s-log-pipeline
spec:
  selector:
    matchLabels:
      app: k8s-log-pipeline
  template:
    metadata:
      labels:
        app: k8s-log-pipeline
    spec:
      hostname: k8s-log-pipeline
      volumes:
        - name: k8s-log-pipeline-config
          configMap:
            name: k8s-log-pipeline-config
            items:
              - key: fluentd
                path: fluent.conf
        - name: k8s-log-pipeline-input-tls-volume
          secret:
            secretName: k8s-log-pipeline-input-tls-secret
            items:
              - key: cert
                path: in.crt
              - key: priv-key
                path: in_priv_key
              - key: ca
                path: in_ca.crt
        - name: k8s-log-pipeline-output-tls-volume
          secret:
            secretName: k8s-log-pipeline-output-tls-secret
            items:
              - key: cert
                path: out.crt
              - key: priv-key
                path: out_priv_key
              - key: ca
                path: out_ca.crt
      containers:
        - name: k8s-log-pipeline
          image: fluent/fluentd:v1.7-1
          volumeMounts:
            - name: k8s-log-pipeline-config
              mountPath: /etc/fluent
            - name: k8s-log-pipeline-input-tls-volume
              mountPath: /etc/secrets/input
            - name: k8s-log-pipeline-output-tls-volume
              mountPath: /etc/secrets/output
          ports:
            - containerPort: 8888
              name: input
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              add:
                - NET_BIND_SERVICE
              drop:
                - all
          env:
            - name: KAUDIT_WEBHOOK
              valueFrom:
                configMapKeyRef:
                  name: k8s-log-pipeline-config-kaudit
                  key: kaudit-webhook
            - name: TLS_IN_PRIVATE_KEY_PASSPHRASE
              valueFrom:
                secretKeyRef:
                  name: k8s-log-pipeline-input-tls-secret
                  key: priv-key-password
            - name: TLS_IN_CA_PRIVATE_KEY_PASSPHRASE
              valueFrom:
                secretKeyRef:
                  name: k8s-log-pipeline-input-tls-secret
                  key: ca-password
            - name: TLS_OUT_PRIVATE_KEY_PASSPHRASE
              valueFrom:
                secretKeyRef:
                  name: k8s-log-pipeline-output-tls-secret
                  key: priv-key-password
            - name: TLS_OUT_CA_PRIVATE_KEY_PASSPHRASE
              valueFrom:
                secretKeyRef:
                  name: k8s-log-pipeline-output-tls-secret
                  key: ca-password
          command:
            - fluentd
---
EOF

kubectl apply -f fluentd_deployment.yaml


2. Prepare Webhook Configuration for k8s API Server
---------------------------------------------------
Create a kubeconfig file for kube-apiserver webhook audit backend. 
The server (URL), client-certificate and client-key should match what is configured for fluentd.

cat <<EOF > /etc/kubernetes/audit-webhook-kubeconfig
apiVersion: v1
kind: Config
clusters:
  - name: kaudit
    cluster:
      server: http://10.97.132.41:8888/audit                 # audit sink URL: <IP of FluentD service>:8888/audit
    certificate-authority:                                   # if over https, then CA of FluentD service (matching its IP if self-signed): /path/to/ca.pem
users:
  - name: minikube                                           # <name-of-api-server>
    user:
      client-certificate:                                    # client authontication certificate, if used: /path/to/cert.pem
      client-key:                                            # client authontication certificate, if used: /path/to/key.pem
contexts:
  - context:
      cluster: kaudit
      user: minikube                                         # <name-of-api-server>
    name: kaudit-context
current-context: kaudit-context
EOF



2) Integration of kAudit via Logstash
=====================================


1. Install and Configure Logstash Configuration
-----------------------------------------------

a. Using Helm chart
Use: https://hub.helm.sh/charts/stable/logstash

b. Using Kubectl

cat <<EOF > logstash_deployment.yaml
---
kind: Service
apiVersion: v1
metadata:
  name: k8s-log-pipeline
spec:
  selector:
    app: k8s-log-pipeline
  ports:
    - protocol: TCP
      port: 9600
      targetPort: 9600
      name: logstash
    - protocol: TCP
      port: 8888
      targetPort: 8888
      name: input
---
apiVersion: v1
kind: Secret
metadata:
  name: k8s-log-pipeline-input-tls-secret
  labels:
    app: k8s-log-pipeline
type: Opaque
stringData:
  cert: |-
    incert
  priv-key: |-
    inprivkey
  priv-key-password: |-
    inprivkeypassword
  ca: |-
    inca
  ca-password: |-
    incapassword
---
apiVersion: v1
kind: Secret
metadata:
  name: k8s-log-pipeline-output-tls-secret
  labels:
    app: k8s-log-pipeline
type: Opaque
#stringData:
#  cert: |-
#    outcert
#  priv-key: |-
#    outprivkey
#  priv-key-password: |-
#    outprivkeypassword
#  ca: |-
#    outca
#  ca-password: |-
#    outcapassword
data:
  cert: ""
  priv-key: ""
  priv-key-password: ""
  ca: ""                              # the CA of the output endpoint (kAudit)  (base64 encoded)
  ca-password: ""
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k8s-log-pipeline-config-kaudit
  labels:
    app: k8s-log-pipeline
data:
  kaudit-webhook: https://kaudit.alcide-kaudit.svc:443/auditsink # kaudit webhook to send to
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: k8s-log-pipeline-config
  labels:
    app: k8s-log-pipeline
data:
  logstash: |
    input{
        http{
            # port should match the exposed container port as well as the k8s WebHook Configuration (kubeconfig) below:
            #    server: http://<logstash-service>/audit:8888
            port=>8888

            # TLS configuration, see: https://www.elastic.co/guide/en/logstash/current/plugins-inputs-http.html#plugins-inputs-http-ssl
            # use SSL
            #ssl => true
            # ssl_key, ssl_certificate should match the k8s WebHook Configuration (kubeconfig) below:
            #    client-certificate: /path/to/cert.pem
            #    client-key: /path/to/key.pem
            # SSL certificate
            #ssl_certificate => "/etc/secrets/input/in.crt"
            # SSL key in the PKCS8 format
            #ssl_key => "/etc/secrets/input/in_priv_key"

            # SSL key passphrase
            #ssl_key_passphrase => "${TLS_IN_PRIVATE_KEY_PASSPHRASE}"
            # SSL cerificate authorities array. For validation of client certificates against these authorities.
            # Need to configure the ssl_verify_mode to peer or force_peer to enable the verification.
            #ssl_certificate_authorities => ["/etc/secrets/input/in_ca.crt"]
        }
    }
    # don't need this for kAudit, as it splits EventLists to events internally
    #filter{
    #    split{
    #        # Webhook audit backend sends several events together with EventList
    #        # split each event here.
    #        field=>[items]
    #        # We only need event subelement, remove others.
    #        remove_field=>[headers, metadata, apiVersion, "@timestamp", kind, "@version", host]
    #    }
    #    mutate{
    #        rename => {items=>event}
    #    }
    #}
    output{
      if [headers][request_path] == "/audit" {
        http {
            id => "alcide-kaudit"
            # kAudit WebHook
            url => "${KAUDIT_WEBHOOK}"
            http_method => "post"
            # default is json; maybe use json_batch?
            format => "json"
            # json; maybe use json_batch?
            content_type => "json"

            # path to X.509 CA (.pem certs) used by kAudit
            cacert => "/etc/secrets/output/out_ca.crt"

            # optional client x509 cert
            #client_cert => "/etc/secrets/output/out.crt"
            # optional client private key
            #client_key => "/etc/secrets/output/priv_key"
            # Keystore options (JKS by default, doesn't work with PEM files): keystore, keystore_password, keysture_type
            # Truststore options (JKS by default): truststore, truststore_password, truststure_type
        }
      }
    }
---
kind: Deployment
apiVersion: apps/v1
metadata:
  name: k8s-log-pipeline
spec:
  selector:
    matchLabels:
      app: k8s-log-pipeline
  template:
    metadata:
      labels:
        app: k8s-log-pipeline
    spec:
      hostname: k8s-log-pipeline
      volumes:
        - name: k8s-log-pipeline-config
          configMap:
            name: k8s-log-pipeline-config
            items:
              - key: logstash
                path: logstash.conf
        - name: k8s-log-pipeline-input-tls-volume
          secret:
            secretName: k8s-log-pipeline-input-tls-secret
            items:
              - key: cert
                path: in.crt
              - key: priv-key
                path: in_priv_key
              - key: ca
                path: in_ca.crt
        - name: k8s-log-pipeline-output-tls-volume
          secret:
            secretName: k8s-log-pipeline-output-tls-secret
            items:
              - key: cert
                path: out.crt
              - key: priv-key
                path: out_priv_key
              - key: ca
                path: out_ca.crt
      containers:
        - name: k8s-log-pipeline
          image: docker.elastic.co/logstash/logstash:7.6.1
          volumeMounts:
            - name: k8s-log-pipeline-config
              mountPath: /usr/share/logstash/pipeline
            - name: k8s-log-pipeline-input-tls-volume
              mountPath: /etc/secrets/input
            - name: k8s-log-pipeline-output-tls-volume
              mountPath: /etc/secrets/output
          ports:
            - containerPort: 9600
              name: logstash
            - containerPort: 8888
              name: input
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              add:
                - NET_BIND_SERVICE
              drop:
                - all
          env:
            - name: KAUDIT_WEBHOOK
              valueFrom:
                configMapKeyRef:
                  name: k8s-log-pipeline-config-kaudit
                  key: kaudit-webhook
            - name: TLS_IN_PRIVATE_KEY_PASSPHRASE
              valueFrom:
                secretKeyRef:
                  name: k8s-log-pipeline-input-tls-secret
                  key: priv-key-password
            - name: TLS_IN_CA_PRIVATE_KEY_PASSPHRASE
              valueFrom:
                secretKeyRef:
                  name: k8s-log-pipeline-input-tls-secret
                  key: ca-password
            - name: TLS_OUT_PRIVATE_KEY_PASSPHRASE
              valueFrom:
                secretKeyRef:
                  name: k8s-log-pipeline-output-tls-secret
                  key: priv-key-password
            - name: TLS_OUT_CA_PRIVATE_KEY_PASSPHRASE
              valueFrom:
                secretKeyRef:
                  name: k8s-log-pipeline-output-tls-secret
                  key: ca-password
          command:
            - logstash
---
EOF

kubectl apply -f logstash_deployment.yaml


2. Prepare Webhook Configuration for k8s API Server
---------------------------------------------------
Create a kubeconfig file for kube-apiserver webhook audit backend.
The server (URL), client-certificate and client-key should match what is configured for logstash.


cat <<EOF > /etc/kubernetes/audit-webhook-kubeconfig
apiVersion: v1
kind: Config
clusters:
  - name: kaudit
    cluster:
      server: http://10.97.132.41:8888/audit                 # audit sink URL: <IP of Logstash service>:8888/audit
    certificate-authority:                                   # if over https, then CA of Logstash service (matching its IP if self-signed): /path/to/ca.pem
users:
  - name: minikube                                           # <name-of-api-server>
    user:
      client-certificate:                                    # client authontication certificate, if used: /path/to/cert.pem
      client-key:                                            # client authontication certificate, if used: /path/to/key.pem
contexts:
  - context:
      cluster: kaudit
      user: minikube                                         # <name-of-api-server>
    name: kaudit-context
current-context: kaudit-context
EOF



3) Direct Integration of kAudit
===============================
1. Prepare Webhook Configuration for k8s API Server
---------------------------------------------------
Create a kubeconfig file for kube-apiserver webhook audit backend.
The server (URL), client-certificate and client-key should match what is configured for logstash.


cat <<EOF > /etc/kubernetes/audit-webhook-kubeconfig
apiVersion: v1
kind: Config
clusters:
  - name: kaudit
    cluster:
      server: http://<kaudit-service IP>/auditsink:443       # audit sink URL: <IP of kAudit service>:8888/audit
      certificate-authority:                                 # if over https, then CA of kAudit service (matching its IP if self-signed): /path/to/ca.pem
users:
  - name: minikube                                           # <name-of-api-server>
    user:
      client-certificate:                                    # client authontication certificate, if used: /path/to/cert.pem
      client-key:                                            # client authontication certificate, if used: /path/to/key.pem
contexts:
  - context:
      cluster: kaudit
      user: minikube                                         # <name-of-api-server>
    name: kaudit-context
current-context: kaudit-context
EOF


4) Applying k8s Audit Configurations
====================================

1. Prepare Audit policy Configuration for k8s API Server
--------------------------------------------------------
The simplest audit policy is as follows. Note that with more specific policy the load on the API-Server and kAudit can be significantly reduce.

cat <<EOF > /etc/kubernetes/audit-policy.yaml
# Log all requests at the Metadata level.
apiVersion: audit.k8s.io/v1
kind: Policy
rules:
- level: Metadata
EOF


2. Apply WebHook and Audit Policy Configurations to the k8s API-Server
----------------------------------------------------------------------

As the API-Server doesn't resolve domain name in the WebHook, the clusterIP of the configured audit sink
should be inserted into audit-webhook-kubeconfig.yaml.
Getting clusterIp of the service:
kubectl get service <service-name> -n <service-namespace> -o=jsonpath={.spec.clusterIP}
For example:
kubectl get service kaudit -n alcide-kaudit -o=jsonpath={.spec.clusterIP}


Put the audit-policy and WebHook configuration files in a directory mounted by the API Server,
and configure it with their paths, generally like this:
--audit-policy-file=/etc/kubernetes/audit-policy.yaml --audit-webhook-config-file=/etc/kubernetes/audit-webhook-kubeconfig

a. Using Kops 
Kops command with a configuration file referencing the required configuration:

kops edit cluster <cluster>

spec:
  fileAssets:
  — name: kaudit-audit-policy
    path: /etc/kubernetes/audit-policy-kubeconfig.yaml
    # which type of instances to appy the file
    roles: [Master]
    content: |
      <audit policy here>
  — name: kaudit-audit-webhook
    path: /etc/kubernetes/audit-webhook-kubeconfig.yaml
    # which type of instances to appy the file
    roles: [Master]
    content: |
      <audit webhook here>
      
  kubeAPIServer:
   auditPolicyFile: /etc/kubernetes/audit-policy-kubeconfig.yaml
   auditWebhookConfigFile: /etc/kubernetes/audit-webhook-kubeconfig.yaml



b. On Minikube (for testing)

1. Copy the following files to be mounted to minikube to ~/.minikube/files, at path /etc/ssl/certs (i.e. ~/.minikube/files/etc/ssl/certs) -
   a directory which is mounted by Minikube's API-Server:
   - audit-policy.yaml
   - audit-webhook-kubeconfig.yaml
   - alcide.crt (if doing direct kAudit integration over HTTPS)
2. Start minikube with a audit policy and webhook configuration:
   minikube start --extra-config=apiserver.audit-policy-file=/etc/ssl/certs/audit-policy.yaml --extra-config=apiserver.audit-webhook-config-file=/etc/ssl/certs/audit-webhook-kubeconfig.yaml
3. Optionally verify kAudit is ready to receive events:
   If kAudit UI or logs do not indicate that audit events are received:
    port-forward svc/kaudit -n alcide-kaudit 7000:443
    curl -d '{"key1":"value1", "key2":"value2"}' -H "Content-Type: application/json" -X POST --cacert <kaudit certificate CA file, for self-signed: kaudit.crt> https://localhost:7000/auditsink
    logs -f kaudit-0 -n alcide-kaudit
    see in log: sink: {:key1 value1, :key2 value2}
4. Check minikube api-server (with a command like: kubectl -- logs -f kube-apiserver-m01 -n  kube-system),
   Make sure no errors like this:
    Error in audit plugin 'webhook' affecting 400 audit events: Post https://kaudit.alcide-kaudit.svc:443/: 
   
